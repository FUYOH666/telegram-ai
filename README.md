# Telegram AI Assistant

Персональный AI-ассистент для личного Telegram аккаунта с интеграцией локального AI-сервера, памятью контекста, Google Calendar, защитой от флуда, обработкой голосовых сообщений и скриптом продаж.

## Быстрый старт

```bash
# Одна команда для запуска (замените путь на ваш реальный путь к проекту):
cd ~/development/TelegramAI && uv sync && uv run telegram-ai

# Или если проект в другом месте:
cd /Users/ваше_имя/путь/к/TelegramAI && uv sync && uv run telegram-ai
```

**Примечание:** Замените `~/development/TelegramAI` на реальный путь к директории проекта.

## Требования

- Python 3.12
- uv (менеджер пакетов)
- Локальный AI-сервер с OpenAI-compatible API (vLLM) на порту 8000
- (Опционально) ASR сервер для транскрибации голосовых сообщений на порту 8001
- Telegram аккаунт
- (Опционально) Google Calendar API credentials

## Установка

1. Клонируйте репозиторий и запустите:
```bash
git clone <repository-url>
cd TelegramAI
uv sync
```

2. Создайте `.env` файл из шаблона (если есть):
```bash
cp .env.example .env
# Отредактируйте .env и добавьте ваши credentials
```

3. Запустите приложение:
```bash
uv run telegram-ai
```

## Конфигурация

### 1. Получение Telegram API credentials

1. Перейдите на [my.telegram.org](https://my.telegram.org)
2. Войдите используя ваш номер телефона
3. Перейдите в раздел "API development tools"
4. Создайте новое приложение, указав:
   - App title: любое название
   - Short name: короткое название
   - Platform: Desktop
5. Скопируйте `api_id` и `api_hash`

### 2. Настройка .env файла

Отредактируйте `.env` файл и добавьте:

```env
TELEGRAM_API_ID=ваш_api_id
TELEGRAM_API_HASH=ваш_api_hash
TELEGRAM_PHONE=+7XXXXXXXXXX

# Опционально, если AI-сервер требует API ключ
AI_SERVER_API_KEY=

# Google Calendar (опционально)
GOOGLE_CALENDAR_ENABLED=false
```

### 3. Настройка config.yaml

Базовые настройки уже настроены в `config.yaml`. Основные параметры:

**AI сервер:**
- `ai_server.base_url` - URL вашего AI-сервера (по умолчанию: `http://100.93.82.48:8000`)
- `ai_server.model` - название модели (по умолчанию: `Qwen/Qwen2.5-14B-Instruct-AWQ`)
- `ai_server.timezone` - часовой пояс для даты/времени (по умолчанию: `Europe/Moscow`)

**Память и контекст:**
- `memory.context_window` - количество последних сообщений для контекста (по умолчанию: 10)
- `memory.max_history_days` - максимальный возраст истории (по умолчанию: 30 дней)
- `memory.auto_summarize` - автоматически создавать summary для старых сообщений (по умолчанию: `true`)
- `memory.summary_threshold` - минимальное количество сообщений для создания summary (по умолчанию: 15)
- `memory.vector_search_enabled` - включить векторный поиск в истории диалогов (по умолчанию: `false`)
- `memory.vector_db_path` - путь к директории ChromaDB (по умолчанию: `./data/chroma_db`)

**Фильтры Telegram:**
- `telegram.handle_private_chats` - обрабатывать личные чаты (по умолчанию: `true`)
- `telegram.handle_groups` - обрабатывать группы (по умолчанию: `false`)
- `telegram.handle_channels` - обрабатывать каналы (по умолчанию: `false`)

**Защита от флуда (Rate Limiting):**
- `rate_limiting.enabled` - включить защиту от флуда (по умолчанию: `true`)
- `rate_limiting.messages_per_minute` - максимум сообщений в минуту (по умолчанию: 10)
- `rate_limiting.messages_per_hour` - максимум сообщений в час (по умолчанию: 50)
- `rate_limiting.block_duration_minutes` - длительность блокировки при превышении (по умолчанию: 10 минут)

**ASR сервер (голосовые сообщения):**
- `asr_server.base_url` - URL ASR сервера (по умолчанию: `http://100.93.82.48:8001`)
- `asr_server.enabled` - включить обработку голосовых (по умолчанию: `true`)

**Скрипт продаж:**
- `sales_flow.enabled` - включить скрипт продаж (по умолчанию: `true`)

**Автоматическое извлечение слотов:**
- `slot_extraction.enabled` - включить автоматическое извлечение слотов через LLM (по умолчанию: `true`)

**Классификация намерений:**
- `intent_classifier.use_llm` - использовать LLM для классификации намерений (по умолчанию: `true`)
- `intent_classifier.confidence_threshold` - минимальный порог уверенности для LLM классификации (по умолчанию: `0.7`)

**RAG система (база знаний компании):**
- `rag.enabled` - включить RAG систему для поиска информации о компании/услугах (по умолчанию: `false`)
- `rag.knowledge_base_path` - путь к директории с документацией (текстовые файлы .txt, .md) (по умолчанию: `./knowledge_base`)
- `rag.max_results` - максимальное количество результатов поиска (по умолчанию: `3`)
- `rag.min_score` - минимальный score для включения результата в контекст (по умолчанию: `0.7`)
- `rag.auto_load_on_startup` - автоматически загружать базу знаний при старте (по умолчанию: `true`)

**Web Search MCP:**
- `web_search.enabled` - включить интеграцию с Web Search MCP (по умолчанию: `false`)
- `web_search.mcp_server_url` - URL MCP Web Search сервера (по умолчанию: `http://localhost:8080`)
- `web_search.max_results` - максимальное количество результатов поиска (по умолчанию: `3`)
- `web_search.max_queries_per_conversation` - максимальное количество запросов за диалог (по умолчанию: `2`)
- `web_search.timeout` - таймаут запроса в секундах (по умолчанию: `10`)

**Google Calendar:**
- `google_calendar.auto_create_consultations` - автоматически создавать встречи (по умолчанию: `true`)
- `google_calendar.available_slots` - доступные слоты времени для встреч

### 4. Google Calendar (опционально)

Если хотите использовать интеграцию с Google Calendar:

1. Перейдите в [Google Cloud Console](https://console.cloud.google.com/)
2. Создайте новый проект
3. Включите Google Calendar API
4. Создайте OAuth 2.0 credentials (Desktop app)
5. Скачайте `credentials.json` и поместите в `credentials/google-calendar.json`
6. Установите `GOOGLE_CALENDAR_ENABLED=true` в `.env`

## Запуск

### Первая авторизация

При первом запуске потребуется:

1. Запустите приложение:
```bash
uv run telegram-ai
```

2. Введите код подтверждения, который придет в Telegram
3. Если включена 2FA, введите пароль

Сессия сохранится в `sessions/scanovichai.session` и повторная авторизация не потребуется.

### Последующие запуски

Просто запустите:
```bash
uv run telegram-ai
```

### Health check команда

Для диагностики состояния приложения используйте команду:
```bash
uv run telegram-ai health
```

Команда проверяет:
- Версию приложения и Python
- Валидность конфигурации
- Доступность AI сервера
- Доступность ASR сервера (если включен)
- Состояние SQLite БД
- Состояние ChromaDB (если включен)
- Наличие Google Calendar credentials (если включен)
- Состояние RAG базы знаний (если включена)
- Статус Web Search (если включен)
- Наличие Telegram сессии

## Использование

### Автоматические ответы

Ассистент автоматически отвечает на сообщения в личных чатах (если включено в `config.yaml`). Ответы генерируются с учетом:
- Контекста предыдущих сообщений
- Актуальной даты и времени (автоматически добавляется в промпт)
- Текущего этапа скрипта продаж (если включен)

### Голосовые сообщения

Если ASR сервер включен (`asr_server.enabled: true`), ассистент автоматически:
1. Принимает голосовые сообщения
2. Транскрибирует их через ASR сервер
3. Обрабатывает транскрипт как обычное текстовое сообщение
4. Отвечает текстом

### Скрипт продаж (Sales Flow)

Если скрипт продаж включен (`sales_flow.enabled: true`), ассистент проходит через этапы:
1. **Приветствие** - знакомство и выявление потребностей
2. **Выявление потребностей** - уточняющие вопросы
3. **Презентация услуг** - рассказ о возможностях Scanovich.ai
4. **Работа с возражениями** - ответы на сомнения
5. **Предложение консультации** - предложение встречи
6. **Согласование времени** - помощь в выборе времени

Переходы между этапами происходят автоматически на основе ключевых слов в сообщениях пользователя.

### Автоматическое извлечение слотов

Если включено (`slot_extraction.enabled: true`), ассистент автоматически извлекает информацию из сообщений пользователя:
- Бюджет, сроки, цели проекта
- Контактная информация
- Детали недвижимости (районы, тип, бюджет)
- И другие параметры на основе контекста

Это сокращает количество вопросов на 30-50% и делает диалог более естественным.

### Summarization для длинных контекстов

Если включено (`memory.auto_summarize: true`), ассистент автоматически:
- Создает краткое резюме старых сообщений при превышении `context_window`
- Сохраняет важную информацию из начала диалога
- Включает summary в начало контекста для сохранения релевантности

Минимальное количество сообщений для создания summary настраивается через `memory.summary_threshold` (по умолчанию: 15).

### Векторный поиск в истории

Если включено (`memory.vector_search_enabled: true`), ассистент:
- Векторизует все сообщения при сохранении
- Находит релевантные сообщения из истории по семантическому сходству
- Добавляет релевантные сообщения в контекст для улучшения ответов

Векторный поиск помогает находить важную информацию из прошлых диалогов, даже если она не в последних N сообщениях.

### ML-based классификация намерений

Если включено (`intent_classifier.use_llm: true`), ассистент:
- Использует LLM для более точной классификации намерений
- Оценивает уверенность в классификации (confidence score)
- Автоматически переключается на keyword-based классификацию при низкой уверенности

Это улучшает точность определения намерений пользователя на 15-25%.

### RAG система для базы знаний компании

Если включено (`rag.enabled: true`), ассистент:
- Автоматически загружает документацию из директории `knowledge_base_path` при старте
- Ищет релевантную информацию из базы знаний перед генерацией ответа
- Добавляет найденную информацию в контекст для более точных ответов о компании/услугах
- Поддерживает текстовые файлы (.txt, .md) с автоматическим разбиением на чанки

**Как использовать:**

База знаний уже настроена и содержит информацию из сайта scanovich.ai и всех GitHub репозиториев:

1. База знаний находится в `./knowledge_base/` и содержит:
   - Информацию о компании и услугах
   - Описания всех проектов (17 репозиториев)
   - Технологии и компетенции
   - Примеры решений по индустриям
   - Возможности и универсальность решений

2. RAG система включена по умолчанию (`rag.enabled: true` в `config.yaml`)

3. При старте приложения база знаний автоматически загружается в векторное хранилище ChromaDB

4. Для обновления базы знаний запустите скрипты:
   ```bash
   uv run python scripts/extract_website_content.py  # Обновить данные с сайта
   uv run python scripts/extract_github_projects.py  # Обновить данные из GitHub
   uv run python scripts/build_knowledge_base.py      # Валидация и сборка
   ```

RAG система использует векторный поиск (ChromaDB) для семантического поиска релевантной информации. При каждом запросе система автоматически ищет релевантные фрагменты из базы знаний и добавляет их в контекст для более точных ответов о компании и услугах.

### Обновление базы знаний

База знаний может быть обновлена вручную или автоматически:

**Автоматическое обновление:**
- Скрипты в `scripts/` автоматически извлекают актуальную информацию
- `extract_website_content.py` - парсит сайт scanovich.ai
- `extract_github_projects.py` - анализирует все GitHub репозитории через GitHub CLI
- `build_knowledge_base.py` - валидирует и собирает базу знаний

**Структура базы знаний:**
- `company/` - информация о компании, услугах, процессе работы
- `projects/` - описания всех проектов, сгруппированные по категориям
- `technologies/` - описание технологий и компетенций
- `use-cases/` - примеры решений по индустриям
- `capabilities/` - возможности и универсальность решений

### Команды Google Calendar

Если интеграция включена:

- `/calendar` или `/events` - показать предстоящие события
- `/create_event Название события | Описание` - создать событие

### Автоматическое создание встреч

Если включено (`google_calendar.auto_create_consultations: true`), ассистент:
- Распознает запросы на консультацию ("хочу консультацию", "когда можем встретиться")
- Использует точное время сообщения от Telegram для определения относительных дат
- Извлекает время из сообщения с поддержкой:
  - **Дни недели**: "четверг", "в пятницу" → вычисляет ближайшую дату
  - **Относительные даты**: "через 2 дня", "через неделю", "через месяц"
  - **Контекстные даты**: "сегодня", "завтра", "послезавтра"
  - **Время**: "14:30", "11 утра", "полдень", "вечером"
- Предлагает доступные слоты времени (если время не указано)
- Автоматически создает событие в Google Calendar при подтверждении
- **Валидирует время**: проверяет что время в будущем и есть минимум 2 часа до начала
- **Предотвращает дубликаты**: проверяет конфликты с существующими встречами

### Управление встречами

Ассистент поддерживает полное управление встречами:

**Перенос встречи:**
- Распознает запросы: "перенести", "изменить", "перенеси встречу"
- Автоматически находит последнюю встречу пользователя
- Извлекает новое время из сообщения
- Обновляет встречу в Google Calendar
- Проверяет конфликты с другими встречами

**Отмена встречи:**
- Распознает запросы: "отменить", "удалить встречу", "отмени встречу"
- Автоматически находит последнюю встречу пользователя
- Удаляет встречу из Google Calendar
- Обновляет контекст пользователя

**Примеры:**
```
Пользователь: "Можем встретиться в четверг в 15:00?"
Ассистент: "✅ Встреча создана на 07.11 в 15:00!"

Пользователь: "Перенеси на завтра в 11:00"
Ассистент: "✅ Встреча перенесена на 06.11 в 11:00!"

Пользователь: "Отмени встречу"
Ассистент: "✅ Встреча отменена."
```

### Защита от флуда

Ассистент автоматически защищает от:
- Слишком частых сообщений (лимиты настраиваются в `config.yaml`)
- Повторяющихся сообщений
- Слишком коротких/длинных сообщений
- При превышении лимитов - временная блокировка с понятным сообщением

## Структура проекта

```
TelegramAI/
├── src/telegram_ai/          # Исходный код
│   ├── ai_client.py           # Клиент для AI сервера (VLLM)
│   ├── calendar.py            # Интеграция с Google Calendar
│   ├── client.py              # Основной Telegram клиент
│   ├── config.py              # Конфигурация приложения
│   ├── intent_classifier.py   # Классификация намерений (keyword + LLM)
│   ├── language_detector.py  # Определение языка сообщений
│   ├── memory.py              # Управление памятью и контекстом
│   ├── rag.py                 # RAG система для базы знаний компании
│   ├── rate_limiter.py        # Защита от флуда
│   ├── sales_flow.py          # Скрипт продаж (state machine)
│   ├── slot_extractor.py     # Автоматическое извлечение слотов через LLM
│   ├── tools.py               # Инструменты для работы с лидами
│   ├── vector_memory.py       # Векторный поиск в истории диалогов
│   ├── voice_handler.py      # Обработка голосовых сообщений (ASR)
│   ├── web_search.py          # Интеграция с Web Search MCP
│   └── main.py                # Точка входа
├── scripts/                   # Скрипты для управления базой знаний
│   ├── extract_website_content.py  # Извлечение данных с сайта scanovich.ai
│   ├── extract_github_projects.py   # Анализ GitHub репозиториев
│   └── build_knowledge_base.py     # Валидация и сборка базы знаний
├── knowledge_base/            # RAG база знаний компании
│   ├── company/               # Информация о компании
│   ├── projects/              # Описания проектов из GitHub
│   ├── technologies/          # Технологии и компетенции
│   ├── use-cases/             # Примеры решений по индустриям
│   └── capabilities/          # Возможности и универсальность
├── tests/                     # Тесты
├── data/                      # SQLite база данных и ChromaDB (создается автоматически)
├── sessions/                  # Telethon сессии (создаются автоматически)
├── credentials/               # Google Calendar credentials (если используется)
├── logs/                      # Логи приложения (создается автоматически)
├── temp_audio/                # Временные аудио файлы (создается автоматически)
├── config.yaml                # Конфигурация
├── rm.md                      # Роадмап улучшений проекта
├── .env                       # Секреты (не коммитится)
└── README.md
```

## Разработка

### Установка dev зависимостей

```bash
uv sync --dev
```

### Запуск тестов

```bash
uv run pytest
```

### Линтинг

```bash
uv run ruff check .
uv run pyright
```

## Безопасность

⚠️ **Важно:**

- Никогда не коммитьте `.env` файл
- Не коммитьте `sessions/` директорию (сессии содержат токены)
- Не коммитьте `credentials/` директорию (OAuth credentials)
- Не коммитьте `data/` директорию (база данных может содержать личные данные)

Все эти директории уже добавлены в `.gitignore`.

## Приёмка

После установки и настройки проверьте, что всё работает корректно:

### 1. Проверка подключения к AI-серверу

```bash
# Проверьте доступность AI-сервера
curl http://100.93.82.48:8000/health || echo "AI сервер недоступен"
```

### 2. Проверка конфигурации

При запуске приложение автоматически валидирует конфигурацию. Убедитесь, что:
- Все переменные окружения установлены (`.env` файл существует)
- `config.yaml` содержит корректные значения
- Пути к файлам (сессии, БД, credentials) правильные

### 3. Проверка авторизации Telegram

После первого запуска:
- Введите код подтверждения из Telegram
- Проверьте, что создался файл `sessions/scanovichai.session`
- При последующих запусках авторизация должна проходить автоматически

### 4. Проверка работы ассистента

1. Отправьте тестовое сообщение в личный чат с вашим аккаунтом
2. Убедитесь, что получили ответ от ассистента
3. Проверьте логи в `logs/telegram-ai-YYYYMMDD.log` на наличие ошибок

### 5. Проверка функций

**Голосовые сообщения (если включено):**
- Отправьте голосовое сообщение
- Проверьте, что оно транскрибируется и обрабатывается

**Google Calendar (если включено):**
- Отправьте команду `/calendar` или `/events`
- Проверьте, что события отображаются

**Rate Limiting:**
- Отправьте несколько сообщений подряд
- При превышении лимита должно появиться сообщение о блокировке

**Memory и контекст:**
- Проведите диалог из нескольких сообщений
- Убедитесь, что ассистент помнит контекст предыдущих сообщений
- Проверьте БД: `sqlite3 data/conversations.db "SELECT COUNT(*) FROM messages;"`

### 6. Проверка тестов

Запустите тесты для проверки основных функций:

```bash
uv run pytest tests/ -v
```

Все тесты должны проходить успешно.

### 7. Проверка линтеров

Убедитесь, что код соответствует стандартам:

```bash
uv run ruff check .
uv run pyright
```

## Устранение проблем

### Ошибка "Configuration validation failed"

Убедитесь, что все переменные окружения установлены в `.env`:
- `TELEGRAM_API_ID`
- `TELEGRAM_API_HASH`
- `TELEGRAM_PHONE`

### Ошибка подключения к AI-серверу

Проверьте:
1. AI-сервер запущен и доступен по адресу в `ai_server.base_url`
2. `ai_server.base_url` в `config.yaml` правильный
3. Нет блокировки файрвола
4. Модель указана правильно в `ai_server.model`

### Ошибка подключения к ASR серверу

Если обработка голосовых не работает:
1. Проверьте, что ASR сервер запущен на порту 8001 (или указанном в `asr_server.base_url`)
2. Проверьте доступность endpoint `/transcribe`
3. Убедитесь, что `asr_server.enabled: true` в `config.yaml`

### Ошибка авторизации Telegram

1. Убедитесь, что credentials правильные
2. Удалите `sessions/scanovichai.session` и попробуйте снова
3. Проверьте, что номер телефона в формате `+7XXXXXXXXXX`

### Проблемы с rate limiting

Если вас заблокировали:
1. Подождите указанное время (по умолчанию 10 минут)
2. Или отключите rate limiting временно: `rate_limiting.enabled: false` в `config.yaml`
3. Или увеличьте лимиты в `config.yaml`

### Настройка Web Search MCP

Если хотите использовать интеграцию с Web Search MCP:

1. Установите и запустите MCP Web Search сервер (см. документацию проекта)
2. Убедитесь, что сервер доступен по адресу, указанному в `web_search.mcp_server_url`
3. Установите `WEB_SEARCH_ENABLED=true` в `.env` или `web_search.enabled: true` в `config.yaml`
4. При необходимости настройте лимиты в `config.yaml`

**Примечание:** Web Search автоматически активируется при обнаружении ключевых слов в сообщении пользователя (например, "актуальные", "новости", "цены", "тренды" и т.д.).

### Настройка RAG базы знаний

Если нужно обновить или изменить базу знаний:

1. **Обновить данные с сайта:**
   ```bash
   uv run python scripts/extract_website_content.py
   ```

2. **Обновить данные из GitHub:**
   ```bash
   uv run python scripts/extract_github_projects.py
   ```

3. **Валидировать базу знаний:**
   ```bash
   uv run python scripts/build_knowledge_base.py
   ```

4. **Перезапустить приложение** для загрузки обновленной базы знаний

**Примечание:** База знаний содержит структурированную информацию без технических деталей кода, фокусируясь на бизнес-возможностях и универсальности решений.

### Логи

Все логи сохраняются в `logs/telegram-ai-YYYYMMDD.log` с детальной информацией для отладки.

## Возможности

### Основные функции

- ✅ **Автоматические ответы** - интеллектуальные ответы на основе контекста диалога
- ✅ **Память контекста** - сохранение истории разговоров в SQLite БД
- ✅ **Summarization** - автоматическое создание резюме старых сообщений для сохранения контекста
- ✅ **Векторный поиск** - семантический поиск релевантных сообщений из истории (ChromaDB)
- ✅ **Динамическая дата/время** - AI всегда знает актуальную дату и время
- ✅ **Защита от флуда** - rate limiting с настраиваемыми лимитами
- ✅ **Голосовые сообщения** - автоматическая транскрибация через ASR сервер
- ✅ **Скрипт продаж** - структурированный процесс продаж с отслеживанием этапов
- ✅ **Автоматическое извлечение слотов** - LLM извлекает информацию из сообщений (бюджет, сроки, контакты)
- ✅ **ML классификация намерений** - LLM-based классификация с confidence scores
- ✅ **Автоматические встречи** - создание событий в Google Calendar при запросах
- ✅ **Управление встречами** - перенос и отмена встреч через естественный язык
- ✅ **Умный парсинг времени** - понимание дней недели, относительных дат, контекстных выражений
- ✅ **Предотвращение дубликатов** - автоматическая проверка конфликтов времени
- ✅ **Валидация времени** - проверка корректности перед созданием встречи
- ✅ **Использование времени Telegram** - точное определение дат на основе времени сообщения
- ✅ **Web Search MCP** - автоматический поиск актуальной информации в интернете
- ✅ **RAG система** - поиск релевантной информации из базы знаний компании перед генерацией ответа
- ✅ **Динамические параметры генерации** - автоматическая настройка по этапам продаж
- ✅ **Детальное логирование** - логи в файлы и консоль для отладки

### Технические особенности

- Модульная архитектура с четким разделением ответственности
- Конфигурация через YAML + переменные окружения
- Fail-fast подход - валидация конфигурации при старте
- Обработка ошибок с понятными сообщениями пользователю
- Поддержка всех типов сообщений Telegram (текст, голос, аудио)

## Лицензия

MIT

## Автор

FUYOH666 (iamfuyoh@gmail.com)

