Улучшение системы работы со встречами
Проблемы текущей системы
Неточное время: Используется datetime.now() вместо времени сообщения Telegram
Ограниченный парсинг: Не понимает дни недели, относительные даты
Нет управления: Нельзя перенести/отменить встречу
Дубликаты: Может создать несколько встреч на одно время
Нет контекста: Не помнит созданные встречи пользователя
Решение: использование времени от Telegram
Telegram предоставляет точное время сообщения через event.message.date (datetime в UTC). Это надежнее, чем угадывать текущее время.

Пошаговый план реализации
Этап 1: Использование времени от Telegram (P0)
Цель: Использовать точное время сообщения вместо datetime.now()

Шаги:

В handle_new_message получать event.message.date (UTC datetime)
Конвертировать в локальную таймзону (Europe/Moscow)
Передавать это время в extract_time_from_message как базовое "сейчас"
Обновить extract_time_from_message для принятия параметра reference_time
Использовать reference_time вместо datetime.now(self.timezone)
Файлы: client.py, calendar.py

---

Этап 2: Расширенный парсинг времени (P0)
Цель: Понимать дни недели, относительные даты, сложные форматы

Шаги:

Добавить парсинг дней недели:
Словарь: {"понедельник": 0, "вторник": 1, ..., "воскресенье": 6}
Поиск в тексте: "четверг", "в четверг", "четверга"
Вычисление ближайшей даты: найти следующий день недели от reference_time
Добавить относительные даты:
"через N дней" → reference_time + timedelta(days=N)
"через неделю" → reference_time + timedelta(weeks=1)
"через месяц" → reference_time + timedelta(days=30) (приблизительно)
Расширить контекстные даты:
"сегодня" → reference_time.date()
"завтра" → reference_time.date() + timedelta(days=1)
"послезавтра" → reference_time.date() + timedelta(days=2)
Улучшить парсинг времени:
"11 утра" → 11:00
"полдень" → 12:00
"вечером" → 18:00 (или из конфига)
"утром" → 10:00 (или из конфига)
Файлы: calendar.py (метод extract_time_from_message)

---

Этап 3: Управление встречами - CRUD операции (P0)
Цель: Добавить поиск, обновление, удаление встреч

Шаги:

Метод find_user_events(user_id, time_min=None):
Поиск событий с summary="Консультация Scanovich.ai"
В описании сохранять user_id в формате user_id:123456
Фильтрация по time_min (только будущие встречи)
Возврат списка событий с event_id
Метод update_event(event_id, new_start_time, new_end_time=None):
Получить событие по ID
Обновить start_time и end_time
Использовать правильную таймзону
Вернуть обновленное событие
Метод delete_event(event_id):
Удалить событие по ID
Логирование успешного удаления
Обновить create_event:
Добавить параметр user_id (опционально)
Сохранять user_id в описании события: f"Консультация с пользователем Telegram\nuser_id:{user_id}"
Файлы: calendar.py

---

Этап 4: Обработка запросов на перенос/отмену (P0)
Цель: Распознавать и обрабатывать запросы на изменение встреч

Шаги:

Метод detect_reschedule_request(message):
Ключевые слова: "перенести", "изменить", "перенос", "изменение"
Ключевые слова отмены: "отменить", "удалить", "отмена", "отмены"
Возврат: ("reschedule" | "cancel" | None, bool)
Метод find_latest_user_event(user_id):
Найти последнюю будущую встречу пользователя
Использовать find_user_events + сортировка по времени
Вернуть event_id и event dict
Логика в client.py:
После detect_consultation_request проверить detect_reschedule_request
Если "reschedule":
Найти последнюю встречу пользователя
Извлечь новое время из сообщения
Если время найдено → update_event
Если не найдено → предложить слоты
Если "cancel":
Найти последнюю встречу пользователя
delete_event
Подтвердить отмену
Файлы: calendar.py, client.py

---

Этап 5: Предотвращение дубликатов (P1)
Цель: Не создавать несколько встреч на одно время

Шаги:

Метод check_time_conflict(start_time, end_time, exclude_event_id=None):
Проверить существующие события в календаре
Проверить пересечение временных интервалов
Вернуть (has_conflict: bool, conflicting_events: List)
Перед созданием встречи:
Вызвать check_time_conflict
Если конфликт → сообщить пользователю
Предложить другое время
Логирование конфликтов для отладки
Файлы: calendar.py, client.py

---

Этап 6: Сохранение контекста встреч (P1)
Цель: Помнить созданные встречи пользователя

Шаги:

При создании встречи сохранять в user_context:
last_event_id: ID последней встречи
last_event_time: время последней встречи (для быстрого поиска)
Обновлять контекст при:
Создании новой встречи
Переносе встречи
Отмене встречи
Использовать контекст для:
Быстрого поиска последней встречи
Предотвращения дубликатов
Улучшения UX (напоминание о встрече)
Файлы: client.py (работа с memory.save_user_context)

---

Этап 7: Улучшенная валидация (P1)
Цель: Проверять корректность времени перед созданием

Шаги:

Метод validate_event_time(start_time, end_time):
Проверка: время в будущем
Проверка: время в рабочих часах (из конфига)
Проверка: время в доступных слотах (опционально)
Проверка: минимальный интервал (например, за 2 часа)
Возврат валидации:
(is_valid: bool, error_message: Optional[str])
Использовать перед созданием/обновлением встречи
Файлы: calendar.py, client.py

---

Этап 8: Улучшенное логирование и отладка (P2)
Цель: Детальное логирование для диагностики проблем

Шаги:

Логировать:
Время сообщения от Telegram (UTC и локальное)
Извлеченное время из сообщения
Созданное/обновленное время события
Время в Google Calendar (для сравнения)
Добавить debug-логи для:
Парсинга времени (какие паттерны сработали)
Поиска встреч пользователя
Проверки конфликтов
Файлы: calendar.py, client.py

---

Технические детали
Использование времени от Telegram
# В handle_new_message:
message_time_utc = event.message.date  # datetime в UTC от Telegram
message_time_local = message_time_utc.astimezone(self.calendar.timezone)

# Передавать в extract_time_from_message:
extracted_time = self.calendar.extract_time_from_message(
    message_text, 
    reference_time=message_time_local
)
Формат сохранения user_id в событии
description = f"Консультация с пользователем Telegram\nuser_id:{user_id}"
Структура user_context для встреч
{
  "last_event_id": "abc123",
  "last_event_time": "2025-11-06T11:00:00",
  "last_event_summary": "Консультация Scanovich.ai"
}
Порядок реализации
Этап 1 (использование времени Telegram) - основа для всего остального
Этап 2 (расширенный парсинг) - улучшает UX
Этап 3 (CRUD операции) - необходимая функциональность
Этап 4 (перенос/отмена) - критично для стабильности
Этап 5 (предотвращение дубликатов) - улучшает надежность
Этап 6 (контекст) - улучшает UX
Этап 7 (валидация) - дополнительная защита
Этап 8 (логирование) - для отладки
Ожидаемый результат
После реализации система будет:

✅ Использовать точное время от Telegram
✅ Понимать дни недели и относительные даты
✅ Позволять переносить и отменять встречи
✅ Предотвращать дубликаты
✅ Помнить контекст встреч пользователя
✅ Валидировать время перед созданием
✅ Детально логировать для отладки